# 문제를 풀 당시 생각 과정을 기입
'''
처음에 감이 바로 잡히지 않아서 완전 탐색을 해보려 했다
하지만 n이 6일때 총 점수의 최댓값을 구하려고 해보면, 최댓값을 결정하는 과정에서
첫번쨰 계단부터 계단이 어떻게 선택되어 왔는가? 가 최댓값에 영향을 주고 있다.
이 부분에서 dp를 의심해볼 수 있었다. n이 6일때 결과값에 n이 5일때, 4일때, 3일때.. 그 이전의 결과값들이 영향을 주고 있으니
이전의 결과값이 재사용되어 n=6을 구성할 수 있을 거라고 생각했다.

그래서 점화식을 처음에 구했는데
처음에는 max(d[i-1], d[i-2] + a[i]) 라고 생각하여 문제를 틀렸다.
왜 그런가 생각해보면, d[i-1]은 최댓값 후보에 들 수 없다.
경우의 수는 3가지로 나뉜다. 3개가 연속하지 않아야 하므로
d[i-1], d[i-2] + a[i], d[i-3] + a[i-1] + a[i] 로 바로 이전 d값, 이전 d값 + 1개 선택, 이전 d값 + 2개 연속 선택 이다.

여기서 d[i-1]이 최댓값 후보가 될 수 없는 이유는 더 쉽게 생각했을 때 찾을 수 있었다.
그냥 d[i]의 최댓값은 d[i-1]이 될 수가 없다. 계단이 하나 더 많은 d[i]인데, 어떻게 구성하든 d[i]는 d[i-1] 보다 클 수 밖에 없다.

따라서 d[i]는 후보에 들 수 없고, max(d[i-2] + a[i], d[i-3] + a[i-1] + a[i])가 점화식이 된다.

---

"마지막 계단을 무조건 밟아야한다"를 고려하지 않았다.
계단을 오르는 방향으로 생각하면 안되고 일단 a[i]는 깔고 시작해야한다.
그리고 a[i-1]을 밟는지 안밟는지로 경우의 수를 나누면
max(d[i-2] + a[i], d[i-3] + a[i-1] + a[i])가 점화식이 된다.

'''

# 풀이 코드 기입
n = int(input())

a = [0]
d = [0] * (n+2)

for i in range(n):
	a.append(int(input()))

if n == 1:
	print(a[1])
elif n == 2:
	print(a[1]+a[2])
else:
	d[1] = a[1]
	d[2] = a[1] + a[2]
	d[3] = max(a[2]+a[3], a[1]+a[3])
	
	for i in range(4, n+1):
		d[i] = max(d[i-3]+a[i-1]+a[i], d[i-2]+a[i])
	
	print(d[n])


# 피드백 후 정리(알게된 점, 포인트 등)
'''



'''
