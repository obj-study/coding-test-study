# 문제를 풀 당시 생각 과정을 기입
'''
- 접근 근거가 무엇인지 적어보기
처음에 감이 바로 잡히지 않아서 완전 탐색을 해보려 했다. 하지만 n이 6일 때 총 점수의 최댓값을 구하려고 해보면, 
최댓값을 결정하는 과정에서 첫 번째 계단부터 계단이 어떻게 선택되어 왔는가가 최댓값에 영향을 주고 있다. 
이 부분에서 DP를 의심해볼 수 있었다. n이 6일 때 결과값에 n이 5일 때, 4일 때, 3일 때... 
그 이전의 결과값들이 영향을 주고 있으니 이전의 결과값이 재사용되어 n=6을 구성할 수 있을 거라고 생각했다.

- 나의 접근에 문제점이 무엇일까 생각해보기
처음에 점화식을 max(d[i-1], d[i-2] + a[i])라고 생각하여 문제를 틀렸다. 왜 그런가 생각해보면, d[i-1]은 최댓값 후보에 들 수 없다.
경우의 수는 3가지로 나뉜다. 3개가 연속하지 않아야 하므로 d[i-1], d[i-2] + a[i], d[i-3] + a[i-1] + a[i]로 바로 이전 d값, 이전 d값 + 1개 선택, 이전 d값 + 2개 연속 선택이다.

여기서 d[i-1]이 최댓값 후보가 될 수 없는 이유는 d[i]의 최댓값은 d[i-1]이 될 수 없다는 점이다.
계단이 하나 더 많은 d[i]인데, 어떻게 구성하든 d[i]는 d[i-1]보다 클 수밖에 없다.

마지막 계단을 무조건 밟아야 한다는 점을 고려하지 않았다. 계단을 오르는 방향으로 생각하면 안 되고, 
일단 a[i]는 깔고 시작해야 한다. 그리고 a[i-1]을 밟는지 안 밟는지로 경우의 수를 나누면 max(d[i-2] + a[i], d[i-3] + a[i-1] + a[i])가 점화식이 된다.


- 시간 복잡도를 고려해보기
해당 풀이의 시간 복잡도는 O(n)이다. 각 계단마다 한 번씩만 계산을 수행

'''

# 풀이 코드 기입
n = int(input())

a = [0]
d = [0] * (n+2)

for i in range(n):
	a.append(int(input()))

if n == 1:
	print(a[1])
elif n == 2:
	print(a[1]+a[2])
else:
	d[1] = a[1]
	d[2] = a[1] + a[2]
	d[3] = max(a[2]+a[3], a[1]+a[3])
	
	for i in range(4, n+1):
		d[i] = max(d[i-3]+a[i-1]+a[i], d[i-2]+a[i])
	
	print(d[n])
