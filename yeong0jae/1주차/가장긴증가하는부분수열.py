# 문제를 풀 당시 생각 과정을 기입
'''
- 접근 근거가 무엇인지 적어보기
먼저 주어진 예시 A = {10, 20, 10, 30, 20, 50}으로 가장 긴 증가하는 부분수열을 구해보려 했다.

10을 골랐을 때, 그 후 30을 골랐을 때, 20을 골랐을 때 등을 고려했다.
"이전에 뭘 골랐는지가 현재에 영향을 준다" -> 결과값이 재사용될 가능성이 높다고 생각했다. -> DP로 접근.
i는 수열의 길이, d[i]는 가장 긴 증가하는 부분 수열의 길이로 잡았다.

포인트는 다음에 나오는 수가 바로 이전에 고른 수보다 크다고 해서 무조건 고르면 안 된다는 것이다.
예: 10 20 10 90 50 70 에서 90을 골라버리면 뒤에 50 70을 못 고르기 때문에 최대 길이가 나오지 않는다.
이전 d값을 어떻게 구성해야 다음 d값을 만들어낼지 고민해야 했다.

처음엔 바로 다음 수, 그 다음 수까지 생각해서 진행해보려 했으나, 적절하지 않았다.

- 나의 접근에 문제점이 무엇일까 생각해보기
시간 복잡도를 통해 힌트를 얻을 수 있었을 것이다.
주어진 수열의 최대 길이는 1000이다. 이를 보고 이중 루프를 사용할 가능성이 높다고 캐치했어야 한다.

- 시간 복잡도를 고려해보기
주어진 문제의 N값이 10,000 이하일 경우 이중 반복을 해야 할 가능성이 높다.
보통 실행시간은 1초고, 1초 동안 처리할 수 있는 연산 횟수는 보통 수억 개(약 10^8 ~ 10^9)로 가정.
O(N^2) 알고리즘은 N^2 번의 연산을 수행.
최대 연산 횟수를 10^8로 가정하면 N <= 10^4로 추정할 수 있다.

'''

# 풀이 코드 기입
N = int(input())
A = list(map(int, input().split()))
dp = [1] * N
for i in range(N):
    for j in range(i): # 점화식을 반복해서 적용해야 비로소 정복되는 유형. 이중 반복문을 이용했다.
        if A[j] < A[i]: # 이전의 a값을 확인하며 작은 것 중 최대 길이 + 1로 갱신한다
            dp[i] = max(dp[i], dp[j]+1)
print(max(dp))

