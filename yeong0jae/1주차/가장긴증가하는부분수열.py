# 문제를 풀 당시 생각 과정을 기입
'''
먼저 주어진 예시  A = {10, 20, 10, 30, 20, 50} 으로 가장 긴 증가하는 부분수열을 구해보려했다.
10을 골랐을 때, 그 후 30을 골랐을때, 20을 골랐을 때..등
"이전에 뭘 골랐는지가 현재에 영향을 준다" -> 결과값이 재사용 될 가능성이 높다고 생각했다. -> dp로 접근

i는 수열의 길이, d[i]는 가장 긴 증가하는 부분 수열의 길이로 잡았다.
i=1 부터 써봤는데, 포인트는 다음에 나오는 수가 바로 이전에 고른 수보다 크다고 해서 무조건 고르면 안된다는 것이다.
예를 들어, 10 20 10 90 50 70 에서는 90을 10, 20을 고르고 90을 골라버리면 뒤에 50 70을 못고르기 때문에 최대 길이가 나오지 않는 것이다.

그러면 이전 d값을 어떻게 구성해야 다음 d값을 만들어낼지 생각해야했다.
처음엔 바로 다음수, 그 다음수 까지 생각해서 진행해보려 했는데, 도저히 아닌 것 같았다.
-----

시간 복잡도를 통해 힌트를 얻었어도 좋았을거다.
주어진 수열의 최대 길이는 1000이다. 1000인 리스트를 보고선 이중 루프를 사용할 가능성이 높다고 캐치했어야 한다.
실제로 풀이에서는 현재 구할 d[i]에 대해 이전의 모든 i값에 대해 더 작은 것을 대상으로 max(dp[i], d[j] + 1)로 갱신한다.

'''

# 풀이 코드 기입
N = int(input())
A = list(map(int, input().split()))
dp = [1] * N
for i in range(N):
    for j in range(i): # 점화식을 반복해서 적용해야 비로소 정복되는 유형. 이중 반복문을 이용했다.
        if A[j] < A[i]: # 이전의 a값을 확인하며 작은 것 중 최대 길이 + 1로 갱신한다
            dp[i] = max(dp[i], dp[j]+1)
print(max(dp))

    



# 피드백 후 정리(알게된 점, 포인트 등)
'''
n값이 10,000 이하일 경우 이중 반복을 해야할 가능성이 높다.
보통 실행시간은 1초고, 1초 동안 처리할 수 있는 연산 횟수는 보통 수억 개(약 10^8 ~ 10^9)로 가정.
O(N^2) 알고리즘은 N^2 번의 연산을 수행
최대 연산 횟수를 10^8로 가정하면
N <= 10^4
'''