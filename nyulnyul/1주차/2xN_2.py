# 문제를 풀 당시 생각 과정을 기입
'''
길이가 2x1과 2x2일때는 각각 방법이 1과 3이 있다.

기존 풀이를 참고하면
마지막에 1x2 타일 하나를 놓는 경우 : 남은 부분은 2x(n-1) 직사각형을 채우는 방법과 같다.
마지막에 2x1 타일 하나를 놓는 경우 : 남은 부분은 2x(n-2) 직사각형을 채우는 방법과 같다.
마지막에 2x2 타일 하나를 놓는 경우 : 남은 부분은
만약 n=3이면
    1x2 타일을 하나 놓는 경우는 앞에 남은 것이 2x2 직사각형
    2x1 타일을 두개 놓는 경우는 앞에 남은 것이 2x1 직사각형
그 이상일때 가로의 길이가 n이라면 n-1일때의 경우의 수와 n-2일때의 경우의 수를 더하면 된다.

f(n) = f(n-1) + f(n-2) 이다.
이전과 달리 1x2, 2x1외에 2x2가 추가되어 경우의 수가 늘었다.

dp라는 동적계획법을 이용해 국소적
'''

# 풀이 코드 기입
n = int(input())
if n == 0:
    print(1 % 10007)  # 2x0 크기의 직사각형을 채우는 방법은 1가지
elif n == 1:
    print(1 % 10007)  # 2x1 크기의 직사각형을 채우는 방법은 1가지
else:
    dp = [0] * (n+1)
    dp[1] = 1
    dp[2] = 3
    for i in range(3, n+1):
        dp[i] = dp[i-1] + 2*dp[i-2]

    print(dp[n] % 10007) # 10007로 나눈 나머지 출력 조건


# 피드백 후 정리(알게된 점, 포인트 등)
'''
2x2 타일을 놓는 경우 남은 부분이 2x(n-2)크기의 직사각형이 되어서 경우의 수는 f(n-2)가 된다.

이때 기존 2x1도 2x(n-2)크기의 직사각형이 되어서 경우의 수는 f(n-2)가 되기에 점화식으로 보면

f(n) = f(n-1) + 2f(n-2)가된다.
'''